# 面向对象OOP
> 什么叫做面向对象?JS就是基于面向对象的思想开发的,浏览器提供了很多的类,我们还可以自己定义类(构造函数模式),我们平时所用的一般都是某一个类的实例.
> 面向过程：以过程为中心。函数的里为了实现某个而效果实现的就是过程。面向对象：是以事物为中心.
>+ 如果想把JS学好,需要按照面向对象的思想,深入研究实例和具体的类即可;
>+ 所有对象划分成类，然后针对某个实例进行研究，通过对这个实例的认识认识这个类中的任何实例
>+ 任何对象（new出来的实例）最终都能通过`__proto__`找到Object
>+ 所有类都是Function的实例
>+ 同时Object.prototype是Function.prototype的上级，因为Function.prototype属于对象，Object是对象中祖基类.

### 1. 面向对象的特点，JS中：
##### 1.1封装：
- 低耦合高内聚
- 耦合是重复，内聚：减少页面的冗余代码，提高代码利用率。
-  封装方法基础思路： 1.首先知道这个而函数的需求 2.知道返回值是什么类型的

##### 1.2 继承：
子类继承父类的属性和方法
    继承：子类继承父类的属性和方法；
- 原型继承：是基于原型链的
- call继承：实现私有属性和私有方法的继承；（具体可以查看正式课第一周周日的讲义--拷贝继承）
- 拷贝继承：for in 循环实现；（通过遍历，可以将一个对象的属性和属性值拷贝给另一个对象，然后对新的对象进行操作，就不影响父级）
- 原型继承：是js中最常用的一种方式，子类B想要继承A中的所有属性和方法（私有+公有），只需要让B.prototype=new A即可。
        因为A的实例拥有这些属性和方法。不是复制一份过来，而是在A和B的原型之间搭建一个桥梁，B的实例可以通过A的实例查找到A的原型对象上的方法。
        //原型继承特点：它是把父类中私有的+公有的都继承到子类的原型上了（变成了子类公有的）。
##### 1.3 多态：多种形态，包括重载和重写
- 重载：js中相同函数名，后面的会把前面的覆盖掉，所以js中不存在重载；但js中有类似重载的思想，即传不同的参数实现不同的效果
- 重写：子类可以重写父类的方法：


### 2 面向对象常用模式：单例、工厂、构造函数、原型。
##### 2.1 单例模式
- 把描述同一事物的属性和方法，放在同一个命名空间下进行分组；避免不同事物相同属性，变量名冲突的问题。
- 单例模式本质：封装一个对象。就是最简单的模块化开发；（seaJS,RequireJS）。
    命名空间：浏览器开辟一个堆内存，给这个内存附上一个名字，比如person1就是命名空间；
- 常见的单例模式使用：模块化开发：对于一个大型项目，分给不同的工程师去完成不同的模块，全部完成之后，把所有模块拼接到一起， 整个项目就完成了。（避免变量名冲突，可以同步开发）；
- 单例模式中可进行各模块之间的相互调用   模块名.属性名；
- 单例模式中本模块之间的相互调用   this.属性名、方法名；
- 单例模式的优缺点：
        优点：1.避免了变量名冲突  2.实现了模块式开发
        缺点：手工作业模式，一个个创建  低效率
        解决办法：工厂模式封装
##### 2.2 工厂模式

- 工厂模式的基本思想： 就相同的代码或者功能进行封装，以后再用，不用重写，直接调用即可。本质就是函数封装。
    需要自己手动创建一个对象，然后添加完属性和方法之后，return一个对象。
- 工厂模式：本质：函数封装  就相同的代码或者功能进行封装，以后再用，不用重写，直接调用即可；
- 缺点：没法解决产品差异化
##### 2.3 构造函数模式
1. 什么是构造函数模式：目的是为了实现一个自定义的类（所有的类都是函数），并能创建一些实例；
2. 工厂模式和构造函数的区别：
- 在执行的时候： 工厂模式:-->函数调用; 构造函数模式-->一个new 类(); 所有的类都是函数，通过new创建出来的构造函数的实例都是对象
- 在里面js代码执行时候：工厂模式：需要自己手动创建一个对象，然后添加完属性和方法之后，return一个对象。 构造函数模式：系统会自动创建一个对象，添加完属性和方法之后，系统会自动返回一个对象
- 构造函数的细节：
        1）创建一个实例时，如果没有参数，小括号可以省略；
        2）关于this指向问题：
            构造函数中的this，指向实例；
            方法中的this:方法调用时，看前面是否有点，点前面是谁，this就是谁
        3）构造函数中，只有this.xx跟实例有关系，跟里面变量没有任何关系
        4)  构造函数执行完，系统会默认返回一个对象，如果我们自己return一个返回值的话：
            1.return基本数据类型值，无效，返回的还是当前这个实例
            2.return引用数据类型，会覆盖掉当前时候实例，此时，实例上的属性和方法都无效了。
        5）构造函数中有nam（函数名）,length（形参的个数），`__proto__`->指向所属类Function.prototype、prototype->它自己本身的原型。
3. 构造函数的优缺点：
- 优点：自定义一个类（函数封装） 可以创建实例；而且系统会自动创建和返回对象
- 缺点：每个方法都是私有的，导致大量冗余代码；（每创建一个实例的时候，私有的方法都会创建一遍，用或者不用的都有，出现大量冗余）
- 解决办法：prototype  把相同的代码放在一个公共的区域；
##### 2.4 原型模式
1. 原型解决的问题：原型prototype上存储的都是公有的属性和方法 解决了构造函数相同方法不相等的问题；
- 方便我们学习对象上所有属性和方法;
- 原型解决了构造函数属性私有的问题，可以让多个构造函数的实例共享一些方法。
- instanceOf   检查一个对象是否属于某个类，但在修改`__proto__`后失效.
- 属性的判断：
        1）for in 可遍历私有属性和共有属性
        2）hasOwnProperty:查看是否是对象上的私有属性
2. 构造函数和原型链的思维差别：
- 构造函数：类  实例（围绕这两个之间的关系）
- 原型模式： 实例  类  原型（围绕这三者间的关系）
3. 原型链：
- 每一个函数(普通函数、构造函数也叫类、Object）都天生自带一个prototype的属性，这个prototype是个对象。 所有的函数都有prototype属性，但是只有在构造函数上才有意义
- 浏览器自带的prototype属性天生自带constructor属性（自己重构的prototype没有这个属性），属性值是当前这个类;原型对象上有，
     说明属于实例的公有属性，每个实例也都有，都指向这个类。constructor可以检测数据类型，但是不知道有没有重构，所以用instanceOf 更保险
- 每个对象（普通对象、prototype、实例）都天生自带一个_proto_的属性，属性值：当前这个实例所属类的原型
- 原型链是通过_proto_来实现
- 原型链是一种查找机制：（原型链是实现继承的关键，是js中独有的一种机制）
        1.对象.属性  首先在自己的私有空间里查找，如果找到，就用私有空间的属性
        2.如果找不到，通过_proto_继续往该实例所属类的原型上找；如果找到，它是一个公有的属性；
        3.如果还找不到，继续通过_proto_往上级对象上找，一直找到Object.prototype...，如果还没找到-->undefined
##### 2.5 HTML和JS中的核心原型解析：
>+ HTMLDivElement(div元素标签类----》每一个DIV元素对象都是这个类的实例，并且每一个HTML元素标签都有一个自己对应的类）;
>+ p标签对应的类--》HTMLParagraphElement;
>+ HTMLCollection(元素集合类 getElementsByTagName/getElementsByClassName)、NodeList(节点集合类 getElementsByName、childNodes)
>+ HTMLDivElement--》HTMLElement元素标签类 --》Element-->Node-->EventTarget--->Object （元素标签原型链）
>+ HTMLdocument-->document-->node-->EventTarget--->Object （document 原型链）
>+ 所有的类都是函数
>+ js中的所有内置类：Number.String Boolean (Undefined Null)  Object Function Array RegExp  Date

5. 可枚举和不可枚举
	for in循环在遍历的时候，默认的可以把自己私有的和在所属类的原型上扩展的属性和方法都可以遍历到。
但是一般情况下，我们遍历一个对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：（所以以后遍历对象的时候要这样多写一行代码）
```
    var obj={name:"zhufeng",age:7}
      for(var key in obj){
     1) if(obj.propertyIsEnumerable(key)){
            console.log(key);}
     2)一般用这种方法 if(obj.hasOwnproperty(key)){
            console.log(key);}
```
### 3 继承
##### 3.1 call继承
--》在子类的构造函数中，父类.call(this)  父类的私有变成了子类的私有。
    把父类私有属性和私有方法克隆一份一摸一样的变成子类私有的。（具体可以查看正式课第一周周日的讲义--拷贝继承）
                   function B(){
                        A.call(this);}
##### 3.2 拷贝继承（冒充对象继承）：
把父类私有的和公有的克隆一份一模一样的给子类私有。for in 循环实现；（通过遍历， 可以将一个对象的属性和属性值拷贝给另一个对象，然后对新的对象进行操作，就不影响父级）
            function B(){
               var temp=new A;
               for(var key in temp){
                //if(e.hasOwnProperty(attr){ 加上这句话就是只继承私有方法
                  this[key]=temp[key];}
                }
##### 3.3 原型继承--》子类的原型继承父类的实例
是js中最常用的一种方式，子类B想要继承A中的所有属性和方法（私有+公有），只需要让B.prototype=new A即可。
        每个B的实例都能通过自己的__proto__找到A上的所有的方法（私有和公有）相对于B都是公有的方法。
    但由于重新修改了B的原型导致B的constructor丢失。
        B.prototype.constructor=B
         因为A的实例拥有这些属性和方法。
        //原型继承特点：它是把父类中私有的+公有的都继承到子类的原型上了（变成了子类公有的）。
        //原型继承的核心：并不是把父类中的属性克隆一份一模一样的给B,而是给B和A之间增加了原型链的链接，以后B的实例n，想要A中的getX方法，
        需要一级一级的向上查找来使用
##### 3.4 混合模式继承：原型模式继承+call继承  （工作中也很常用的一种方式）
弊端：私有的会重复（子类原型上多了一套父类的私有属性）   因为call会继承私有的属性和方法，通过原型继承可以继承私有的和公有的，所以私有的属性和公有的属性有重复的。
##### 3.5寄生组合式继承
```
B.prototype=Object.create(A.prototype)但是Object.create不兼容
          所以重写一个方法：B.prototype=Object.create(A.prototype)
          function myCreate(o){
               function Fn(){};
                 Fn.prototype = o;
                 return new Fn();
    }
```

##### 3.6 中间件继承法--不兼容-  __proto__ 不兼容IE
Child.prototype.__proto__ = Parent.prototype;//把父类的公有的当做子类的公有的

