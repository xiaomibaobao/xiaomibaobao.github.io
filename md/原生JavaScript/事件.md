# 事件
标签： javascript event DOM0级事件 DOM2级事件 IE兼容处理 事件冒泡
>事件指的是在浏览器内外发生的一件事，或者一个行为。
    所以对于任何元素来说不管是否给其绑定方法，只要当前行为触发，那么事件就会触发浏览器感知；

---
## 事件绑定（事件监听）
给元素的某一个事件绑定一个方法，当事件**触发**的时候，会把**绑定**的方法执行。
## 事件对象
##### 1. 来源
    事件触发的时候，相关绑定的方法都会被依次执行，不仅仅执行，浏览器还会默认给每一个方法传递一个**参数值**-->事件对象。
    事件源`e.target`：存储在时间对象中，用来标识事件是由哪个元素发生的
###### 2. 分类：
- 鼠标事件对象MouseEvent\
- 它是MouseEevnt类的一个**实例**。用来存储当前鼠标本次操作**相关信息**的。
    常用的属性有：
`e.clientX e.clientY`,鼠标距离 '当前屏幕窗口 ' 左端、上端的距离。
`e.type`:存储的是当前操作的事件类型，-->click；
- 以下都有兼容问题：
 `e.pageX,e.pageY`,当前鼠标操作这一点的距离‘body左上角（第一屏左上角）’的X/Y轴距离。
- 键盘事件对象KeyboardEvent
    >它是KeyboardEvent类的一个**实例**。
    最常用的属性是`ev.keycode`--->存储的是按下键的编码值，每一个键盘上的键都有一个自己的固定编码值。这是一些比较常用的keycode值
`Ctrl：17`  `Alt:18`  `Space:32`   `enter:13` `backspace:8` `del:46`  `shift:16` `Alt+tab:9``f11:122,全屏` `左上右下37,38,39,40`
 
- 事件对象的兼容问题处理：
 >标准浏览器中-->事件对象是作为形参自动传给事件驱动函数的。ie浏览器中-->事件对象保存在window.event；
 
```javascript
if (!ev) {//->说明没有传递ev的值,当前的浏览器是IE6~8,我们把一些不兼容的属性都按照标准的浏览器实现一遍
    ev = window.event;
    ev.target = ev.srcElement;
    ev.pageX = ev.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
    ev.pageY = ev.clientY + (document.documentElement.scrollTop || document.body.scrollTop);
    ev.preventDefault = function () {
        ev.returnValue = false;//处理事件的默认行为，比如拖拽时防止浏览器误以为要选中文字。
    };
    ev.stopPropagation = function () {
        ev.cancelBubble = true;//处理事件冒泡
    };
}
```
> 另：阻止A标签的默认行为的方法：

``` 
1）<a href="javascript:;">123</a>；<a href="javascript:false/true/null/undefined;">123</a>；？
2），<a href="javascript:void 0;">123</a>;  
3），a标签点击的时候，先把click事件触发，然后才会执行自己的默认跳转（herf），此时可以return false来阻止或者e.preventDefault,注意兼容(ie->returnValue = false;)。
```

## DOM 0级事件
> 给元素对象的某一个事件私有属性赋一个值（一个函数值）；当元素的事件触发的时候，找到对应属性值(可以是函数），让其执行。
0级事件绑定只能给元素的某一个事件绑定一次方法，绑定多次，最后绑定的方法会吧前面所有绑定的方法都覆盖。
 
```javascript
window.onload=function(){}   //当前页面的HTML结构、图片、文字等所有资源都加载完成，才会触发这个事件，在同一页面中只能使用一次。
    //原理：因为它采用DOM 0级事件绑定，只有绑定一次，后面绑定的方法会吧前面的覆盖掉；load事件本身就是资源加载完成触发。
    所以<script>标签如果放在body之前，应该使用window.onload。
```

## DOM 2级事件
-  DOM 2级事件可以给当前元素的某一个事件行为绑定**多个不同**的方法.
原理：默认的会给当前元素的某一个事件创建一个‘内置事件池’，我们通过DOM2给元素的某一个事件绑定的所有方法都会依次的存储到这个容器中，当事件触发的时候，浏览器会默认找到事件池，会吧容器中存储的所有方法依次的执行。 

- `addEventListener` 实现绑定`removeEventListener`来实现移除绑定。需要注意的问题有：
>+ 当事件触发的时候，会到对应的事件池中把所有绑定的方法依次的执行。此时不管哪个方法中的this都是当前元素。
>+ 我们按照绑定的先后顺序，分别把绑定的方法增加到了内置的事件池中，后面绑定的在事件池的最后面。
>+ 如果当前的这个方法已经给元素的这个行为绑定过一次了，在绑定也不会再往事件池中重复增加了，所以导致我们只能给某个元素的某个行为 绑定多个”不重复的方法“；
>+  最后一个参数一般写**false**，让绑定的方法在事件的**冒泡传播**阶段执行。true让方法在事件传播的捕获阶段执行。
>+removeEventListener，移除的时候，三个参数一个不能少，并且需要和绑定的时候一模一样才可以移除。DOM0事件的移除用null即可，DOM2的匿名函数无法移除，所以DOM 2事件绑定一般用实名函数，方便移除。
>+ DOM   0和2是可以共存的。原理不同。

```
在引入jQ之后，$(document).ready(function(){}) 简写 $(function(){} )，它采用的是DOM二级事件绑定。并且采用的是DOM二级中独有的事件进行绑定的:DOMContentLoaded(HTML结构加载完成)
当前页面的HTML结构加载完成就会触发，可以在一个页面中使用多次，所有的事件绑定都是异步编程的。
```

## IE下的DOM 2级事件及其兼容问题
>+ 绑定的方法以及语法是不一样的。 document.body.attachEvent("onclick",fn1 )    参数只能两个，第一个参数要加on，默认只能在冒泡阶段发生，不能控制在捕获阶段。
>+ 'this'问题：事件触发，执行对应的每一个方法的时候，标准浏览器下，方法中的this 是当前的元素，IE6-8下方法中的this是window。
>+标准浏览器中，如果当前元素某一个事件绑定的方法中不能重复，如果绑定过不再重复的绑定了，所以最后执行的时候只执行一次，但是IE6-8下没有实现去重，哪怕方法重复了，也都会给当前元素绑定上，当执行的时候，绑定几次就重复执行几次。
>+ 顺序问题：标准浏览器下方法执行的顺序是按照绑定的顺序依次进行的，但是ie6-8下执行的顺序和绑定的顺序无关，是混乱的。

## 事件传播（冒泡和捕获）
>事件的冒泡传播：当前元素的某一个行为被触发，那么它所有**父级元素**的相关行为都会被触发，这种事件的传播机制叫做"冒泡传播"；

- 冒泡传播和事件是否被绑定无关，
- mouseenter 和mouseover的区别：
>+ mouseenter默认阻止了事件的冒泡传播，子元素的mouseenter事件被触发，父级的相关事件不会背触发。但是mouseover存在冒泡传播，
>+ 当鼠标先从父到子，再从子到父，会重新触发绿盒子的mouseover但是不会触发绿盒子的onmouseenter，

**事件委托**：利用了冒泡机制，当容器中某个子元素的相关行为触发，当前容器的相关行为也会被触发，如果给容器这个事件绑定了方法，方法也会被执行，在执行的时候我们可以获取到事件源（当前操作的元素），我们可以通过事件源是谁来做不同的操作



