# 函数

> 什么是JS中的函数？可以通过函数的三种角色来阐明：
1. 普通函数：当方法运行的时候，形成一个私有作用域，然后
        `形参赋值`，`预解释`，`JS代码逐行执行。`
2.  构造函数（类），new+首字母大写的函数名，构造函数里有自己的原型对象（prototype），构造函数里通过this。xx==xx设置的属性都是实例的私有属性，this就表示某一个实例，hasOwnProperty可以判断是私有属性还是公有的属性。
3. 函数也是对象，只是函数比较特殊，因此单独成function类型，
                `  fn instanceofof Object--》true`，可以像对象一样设置自己的属性和值。
>+ 这三种角色之间相互独立，没有关系。
>+ 所有的函数都是Function（构造函数）类的实例，
>+ 所有的对象都是Object类的实例。  任何对象（new 出来实例）最终都通过__proto__找到Object；

### 声明函数和匿名函数的区别
```
  var creatSth=1;
    function creatSth(){
        return 2;
    }
    console.log(creatSth);//1，因为此时上面的function是声明函数，根据预解释机制，已经声明过的不会再声明，所以返回1.
    var creatSth=function(){
        return 3;
    }
    console.log(creatSth);//3，这个返回的function是匿名函数，但整个式子是函数表达式，在JS执行过程中会覆盖之前的同名变量。
```
### 函数本身具有的属性：
length:0  形参的个数
            name:"Fn"  函数名属性
            prototype:（本身是个爹，指向原型）类的原型，在原型上定义的方法都是这个类实例的公有方法
            __proto__：（函数本身也是个儿子，指向所属类Function的原型）把函数当做普通的对象，指向Function这个类的原型
### 预解释：变量提升
当前作用域下，代码执行之前，对带`var`或`function`关键字的提前声明和定义。
JS中的内存按照功能的不同
`1,栈内存，提供了一个供JS代码执行的环境，全局作用域，私有作用域。`
`2，堆内存，引用数据类型的值）函数代码字符串）对象类型的键值对）`

>+ 首先，页面加载的时候，浏览器会提供一个供JS代码执行的环境--》`全局作用域`
 1，最外层`var`，最外层`function`
 2，所有`未定义直接赋值的变量`自动声明为拥有全局作用域
 3   所有`window对象`的属性拥有全局作用域 

**var关键字**的，在预解释的时候是声明，declare； 
```
  var  num=12; //1,全局作用域声明变量sum=12，在全局环境下会预解释。并增加window属性window.num=12,
num2=12、//仅仅是window.num2=12,
//此外：
var str='xiaomi'
//执行步骤：1，在代码执行之前，声明一个变量str；（预解释）也相当于给window增加了一个属性，但是没有值。
//2，在代码执行的时候，开辟一个内存空间，保存xiaomi这个数值。
//3，把xiaomi这个数据赋值给变量str，值和变量关联起来，
```
 **function**
 预解释的时候是`定义=声明+初始化`。包括开辟内存空间。
 `运行`的时候，也会提供一个供JS代码执行的环境--》`私有作用域`。称之为**闭包，** ,可以保护方法体里的内容不受外界的污染（干扰，），是一种**保护机制**。
 - `作用`：1防止变量名冲突，2，通过传参的方式，对全局变量在私有作用域里重新赋值。
 - 如果想把外界的变量传到闭包中：通过`传参`的方式，对全局变量在私有作用域中重新赋值。
 - 把闭包里的值传到外面   ：可以通过给`window添加属性`的方式。2，`return`，外面设置一个变量接受return的值。
 -  `定义`：1，开辟内存空间，2，将方法体内容以字符串形式存在内存中，3，将引用地址赋值给方法名。此时，方法名代表整个方法。
 -  `运行`：若有`形参`，先行给形参赋值。然后`预解释`。最后按如下将代码自上倒下执行。
            1，重新开辟一个内存空间（栈内存）。
            2 ，将方法体内的字符串变成js语句。
            3，每运行一次就会开辟一个封闭的内存空间。这就是闭包。起保护作用，
            4，return xxx，把方法运行的结果返回给变量xxx，
              `tips： `  
               1，如果没写return或者return后面没有返回值，方法的返回值就是`undefined。`
                    2，遇到return，方法终止，后面的代码不在运行。
                    3，return并不是一定要写，如果需要返回值就必须写。

>+ 如何`查找上级作用域，`
1，先判断当前函数是在哪个作用域下定义的，上一级作用域就是哪个。和方法在哪里执行无关。
2，查找过程形成`作用域链`，保证函数里的私有变量可以有序访问。
3，下级作用域可以查找相应上一层的作用域。反之则不能。即`可以从里往外，反之不行。`

>+ 函数`不进行预解释`的情况：
- 方法当值存在时，不预解释,即声明函数的时候。
       或者可以说：变量声明，只走=左边（如果把函数赋值给变量，按变量值来声明，）=右边不预解释。
- 自执行函数，定义+执行一起做了，也不预解释
    (function () {
    })()
- 不管if条件是否成立，都走预解释。
- 函数这边，return    后面的函数，不进行预解释。
                                   下面的代码  不再执行，但是var和function会预解释。
- 重名变量变量名字重复的话，不重复声明，在预解释的时候只会声明（预解释）一次，后面只是多次的赋值。
```
    var creatSth=1;
    function creatSth(){
        return 2;
    }
    console.log(creatSth);//1，因为此时上面的function是声明函数，根据预解释机制，已经声明过的不会再声明，所以返回1.
    var creatSth=function(){
        return 3;
    }
    console.log(creatSth);//3，这个返回的function是匿名函数，但整个式子是函数表达式，在JS执行过程中会覆盖之前的同名变量。
```
     
### 内存释放

##### 堆内存，引用数据类型的值、函数代码字符串、对象类型的键值对、
**引用数据类型**在定义的时候都会`开辟一个堆内存`并引用地址,,如果外面有变量等`知道`了这个地址,我们就说这个内存被`占用`了,就不能销毁.
```
普通变量和对象
    var obj={'a':11,'b':22};
    var num=12;  ///只有页面被关闭的时候，这两个变量才能被释放掉。
    obj=null;//当前堆内存没有任何东西被占用.
    num=null;//浏览器在空闲的时候，会寻找空指针（空引用）并释放。
高程3 最后一章.内存释放机制.
```

##### 栈内存,提供了一个供JS代码执行的环境，全局作用域，私有作用域。
>+ 全局作用域//不销毁,只有在页面关闭的时候,才销毁.
>+ 私有作用域,//只有函数执行才会产生私有作用域   
 -  一般情况下,函数执行会形成一个新的私有作用域,当私有作用域中的代码执行完成后,我们当前作用域都会`主动`的进行释放和销毁.
 - 特殊情况下,当前私有作用域中的部分内存被`作用域以外的东西`占用了,当前这个作用域就不能销毁了.
                   a)函数执行返回了一个引用数据类型的值,并且在函数的外面被一个其他的东西给接收了,这种情况下一般形成的私有作用域不销毁
    通过DOM方法获取的元素/元素集合都是对象类型的的值..
                    b)在一个私有的作用域中，给DOM元素的`事件绑定方法`，一般情况下私有作用域不销毁。
                   c)下述情况不立即销毁:f返回的函数没有被其他东西占用，但是还需要执行一次，`暂时`不销毁，当返回的值执行完成后，浏览器会在空闲的时候把它销毁。

### 回调函数：
 把一个函数作为`一个参数的值`传递给另外一个函数。在另外一个函数中，把传递进来的函数执行一次或者多次。
>+ 优点：-
- 节省变量名占用，特别是全局变量，
- 委托函数调用操作，节省代码，
- 性能（例如合并函数，减少循环）。
- 根据需求调整代码。

>+ 可以在A函数中尽情操作B函数，
>+ 还可以在A函数中的任何位置执行B函数N次。
>+ 并且还可以给B函数传递对应参数值。
>+ 不仅仅可以传递相应参数值，还可以修改回调函数中的this指向。默认的是window。
>+ 不仅仅可以改变this，还可以接受回调函数执行的返回值。

##### forEach	
用来`遍历`数据中的每一项的，它的第一个参数值是一个回调函数a。  第二个参数是将执行体中的`this`指向的修改。
- 数组中有几项，我们就让这个匿名回调函数执行几次。
- 不仅仅执行了了a，还可以给a传递三个参数值。item：数组当前这一项的值；index，索引，input原始数组。
-  默认情况下，forEach方法并没有改变回调函数中的this指向，默认的this依然是window。forEach支持第二个参数值，第二个参数值都是让回调函数a中的this变为第二个参数的值。
- forEach方法仅仅是用来遍历数组中的每一项的，它本身并不支持返回值（所以用一个变量接受他的返回值是undefined），它的回调函数中写return，对程序本身无影响。
- 封装并兼容IE678
```
 Array.prototype.myForEach = function myForEach() {
        var callback = arguments[0], context = arguments[1] || window;
        if (typeof callback !== "function") {
            return;
        }
        if ("forEach" in Array.prototype) {
            this.forEach(callback, context);
            return;
        }
        //->IE6~8
        for (var i = 0, len = this.length; i < len; i++) {
            callback.call(context, this[i], i, this);
        }
    };
```
**map**：和forEach基本操作一模一样，但是map是`支持返回值`的，在匿名回调函数中return的是啥，都相当于把当前数组中的这一项改变为啥，可以用来根据原数组生成新数组。原数组不变。

### 一些有关函数的小知识：
>+ 括号表达式:
一个小括号中有多项,中间用逗号隔开,我们最后获取的只是最后一项
(fn1, fn2)(); ->只把fn2执行了

>+ eval("12,23,34,45,56");//->(12,23,34,45,56) ->56 首先转换成JS表达式,但是表达式本身又是一个括号表达式,所以最后获取的总是最后一项
>+ 自执行函数，或者eval有多个括号，会一直走。eval('alert')('x')--》会执行ale

>+ 请尽量避免使用Function（）eval（）setTimeout（）进行函数构造，他们会把括号中的内容以字符串形式通过js代码检测。

### 一道常被人轻视的web前端常见面试题(JS)

分享下我曾经看到的一道面试题，此题是用来考核面试者的JavaScript的综合能力，很可惜到目前为止的将近两年中，几乎没有人能够完全答对，并非多难只是因为大多面试者过于轻视他。
题目如下：
```
    function Foo() {
        getName = function () {
            alert(1);
        };
        return this;
    }
    Foo.getName = function () {
        alert(2);
    };
    Foo.prototype.getName = function () {
        alert(3);
    };
    var getName = function () {
        alert(4);
    };
    function getName() {
        alert(5);
    }
    //请写出以下输出结果：
    Foo.getName();
    getName();
    Foo().getName();
    getName();
    new Foo.getName();
    new Foo().getName();
    new new Foo().getName();
```

此题是我综合之前的开发经验以及遇到的JS各种坑汇集而成。此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。
此题包含7小问，分别说下。
#####第一问
先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。
第一问的 Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2，没什么可说的。
##### 第二问
第二问，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以跟1 2 3都没什么关系。此题有无数面试者回答为5。此处有两个坑，一是变量声明提升，二是函数表达式。
变量声明提升
即所有声明变量或声明函数都会被提升到当前函数的顶部。
例如下代码:
console.log('x' in window);//true
var x; x = 0; 
代码执行时js引擎会将声明语句提升至代码最上方，变为：
var x;
console.log('x' in window);//true
x = 0; 

函数表达式
var getName 与 function getName 都是声明语句，区别在于 var getName 是函数表达式，而 function getName 是函数声明。关于JS中的各种函数创建方式可以看 大部分人都会做错的经典JS闭包面试题 这篇文章有详细说明。
函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。
例如下代码：
console.log(x);//输出：function x(){}
var x=1;
function x(){} 
实际执行的代码为，先将 var x=1 拆分为 var x; 和 x = 1; 两行，再将 var x; 和 function x(){} 两行提升至最上方变成：
var x;
function x(){}
console.log(x);
x=1; 

所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。
同理，原题中代码最终执行时的是：
function Foo() {
getName = function () { alert (1); };
return this;
}
var getName;//只提升变量声明
function getName() { alert (5);}//提升函数声明，覆盖var的声明
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
getName = function () { alert (4);};//最终的赋值再次覆盖function getName声明
getName();//最终输出4 
##### 第三问
第三问的 Foo().getName(); 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。
Foo函数的第一句 getName = function () { alert (1); }; 是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。 
此处实际上是将外层作用域内的getName函数修改了。
注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。
之后Foo函数的返回值是this，而JS的this问题博客园中已经有非常多的文章介绍，这里不再多说。
简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。
遂Foo函数返回的是window对象，相当于执行 window.getName() ，而window中的getName已经被修改为alert(1)，所以最终会输出1
此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。
##### 第四问
直接调用getName函数，相当于 window.getName() ，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为
##### 第五问
第五问 new Foo.getName(); ,此处考察的是js的运算符优先级问题。
js运算符优先级:


通过查上表可以得知点（.）的优先级高于new操作，遂相当于是:
new (Foo.getName)(); 
所以实际上将getName函数作为了构造函数来执行，遂弹出2。
##### 第六问
第六问 new Foo().getName() ，首先看运算符优先级括号高于new，实际执行为
(new Foo()).getName() 
遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的构造函数返回值问题。
构造函数的返回值
在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。
而在js中构造函数可以有返回值也可以没有。
1、没有返回值则按照其他语言一样返回实例化对象。

2、若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。

3、若返回值是引用类型，则实际返回值为这个引用类型。

原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。
之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。
遂最终输出3。
第七问
##### 第七问, new new Foo().getName(); 
同样是运算符优先级问题。
最终实际执行为：
new ((new Foo()).getName)(); 
先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。
遂最终结果为3


##### //答案：
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3 