
# 正则表达式

### 1最难的部分：正则字符：
> 为什么这个是最难的呢？方法什么的好记忆，这个字符确乱的很，正则虽然只是一种表达式，但是对我们开发者来说，正则基本就是一门语言，既然是语言，那我们就要先把单词记住，这是最短，也是最有效的路。
> 正则在JS中天天都会用到，可我周围的大部分人都是抄，有些时候一点点小问题自己写个正则就能解决的，如果不会正则会绕很大一圈，我还是决定把我多年的正则笔记拿出来分享一一下。

 首先：正则由两部分组成：元字符和修饰符

##### 1.1元字符：
>+ 代表特殊意义的元字符

- `\` 转义
- `|` 或
- `()` 分组
- `.` 除了\n以外的其他任意字符
- `\n `换行元字符（在控制台换行）
- `\b`单词边界，开头结尾和空格 'w1  w2 w3' 定义是`\w 和\W之间的叫\b`
- `^ `开头
- `$` 结尾
- `[abc] `abc三个中的任何一个
- `[^abc] `除了abc三个中的任何一个
- `[a-z]`  任意一个字母
- `[^a-z] `除了字母以外的任意字符
- ` \d` 数字  `   \w `字母数字下划线    `\s `空格   代表所有看不见的字符，比如空格，回车，tab等。
- ` \D` 非数字  ` \W `非字母数字下划线   ` \S `非空格

>+ 代表次数的量词元字符

- ` * `0到多次
-  `+ `1到多次
-  `? `0次或1次
-  `{n}` 代表n次
- ` {n,}` 至少n次
- `{n,m}` n到m次

##### 1.2修饰符

- `g` 全局的意思
- `i `忽略大小写
- `m `换行操作 多行操作

### 2 最简单的部分：正则的特点和相应的方法：

> 单词都背完了，你还怕什么呢？gogogo！
正则捕获四种方式，test，exec，match，replace。

##### 2.1 创建正则的方式及其特点：
创建：
- 实例创建，`var reg=new RegExp("\\d"),`
- 字面量创建：`var reg=/\d/`

特点
- 实例创建特殊意义的元字符需要转义。字面量不需要。
- 在实例创建中，可以进行变量拼接，但是字面量方式不可以。

##### 2.2 test，exec
1.  test--》字符串是否和定义的模型相匹配。

>+ `reg.test(str);//如果匹配，返回true，反之false。`
  
2. exec 把相匹配的内容提取出来。  exec 捕获的特性:

>+ 返回一个值一次，拿到的是数组。[item ,index ,input]
>+ exec如果没有值，返回null，下一次I的时候，浏览器自动赋值lastIndex 再次变为0.
>+ `懒惰，`正则默认仅查找与之匹配的第一个字符串，然后停止查找，reg.lastIndex 如果不添加全局g，lastIndex永远从0开始查找。不仅仅是exec，包括test。原因是lastIndex，这个值中保存着下一次捕获开始查找的位置。lastIndex值可以手动指定。
>+ **解决措施：** `全局修饰符g`；**原因，**改变了reg.lastIndex 的查找位置，
  lastIndex如果有一次找不到，返回false，他的值会被浏览器默认会自动赋值0；
>+ `贪婪，`正则的`每次`捕获都是按照匹配`最长`的结果捕获的（2和2015都符合，默认返回2015）**。解决：在**量词之后加`？`.

##### 2.3 match search replace 

1. **match**（）和search类似，他返回一个数组，数组包含匹配的文本。、
>+ **match和exec的区别**
>+ 不加g时，exec和match是一样的。）
>+ 加了g之后：match只能捕获到大正则，如果需要对大正则进行细分，match无法拿到大正则中的小分组。exec可以通过括号拿到小正则。
2.  **search()** 如果找到，则返回这个字符位置，只接受一个参数，就是Reg对象，这个方法和`全局标记g无关。`

3.  **replace：**
>+ **第一种情况**`str=str.replace（a，b） `把原有的a字符替换成新b字符
在不使用正则的情况下，replace执行一次只能替换一个字符。正则加g才能全部替换。
>+ **第二种情况**第二个参数换成函数：`str=str.replace（RegExp，function）`此时function是回调函数。
>+  传递进入的这个匿名函数执行几次：正则和字符串匹配的次数，匹配一次执行一次。
>+ 每执行一次匿名函数，都会吧当前匹配的内容当作参数（arguments）传递给匿名函数。里面传递的参数值（arguments）和我们通过exec捕获到的是类似的（[内容；索引；原字符串]）。即使正则有分组，我们同样可以通过arguments获取到分组捕获的内容。
>+  每一次执行匿名函数，return的啥，  都相当于把当前这一次大正则所匹配的内容成啥。
>+   `RegExp.$n:`不管是使用test/exec匹配捕获一次后,`RegExp.$n`记录了第n个分组中所匹配的内容 ->n的最大值到9
>+  函数中`RegExp.$1`就是获取正则中第一个捕获的内容。在匿名函数中使用`”RegExp.$1“ `在IE下有兼容性问题。在外面用没问题。

##### 2.4 常用用法总结  这里是最容易让你晕的时候。

1. 关于`括号()`的用法总结：
>+ ，提高优先级
>+ ，分组功能，和exec联系。
    var reg=/^(\w)\1\(\w)\2$/     `\2`代表和第二个分组出现一模一样的的内容，一模一样代表内容和值都一样。
>+  （？：）只匹配，不捕获           （？：\d{2}）

2. `？`总结：  
>+ ？：表示出现0-1次。{0,1}  0次或则1次 
>+  如果问号的左边是一个非量词元字符,例如:var reg=/\d?/,代表的意思是:当前的问号本身是一个量词元字符,出现0-1次
>+  如果？放在量词后面，是用来解决正则贪婪性。例如:var reg=/\d+?/,
>+  （？：）只匹配，不捕获。
>+   (?=)正向预查
>+  （？！）负向预查。

3. `中括号[]`的用法：
>+  中括号出现的任何字符都没有特殊含义。
>+  中括号不支持两位数     只能匹配一位数，/[12-65]/1,或者2-6，或者5
```
//自己编写循环把所有匹配的都捕获到:大正则/小分组的内容都可以分别的捕获到
        var reg = /(\d)+/g;
        var str = "xiaomi2016xiaomi017xiaomi2018";
        var ary = [], ary2 = [];
        var res = reg.exec(str);
        while (res) {
            console.log(res);
            ary.push(res[0]);
            ary2.push(res[1]);//==>ary2.push(RegExp.$1);
            res = reg.exec(str);
        }
        console.log(ary, ary2);//->["2016", "2017", "2018"] ["6", "7", "8"]
```
4. 老大封装的格式化时间的函数：
```
正则格式化时间：
    String.prototype.myFormatTime = function myFormatTime() {
        var reg = /^(\d{4})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?: +)?(\d{1,2})?(?:-|\/|\.|:)?(\d{1,2})?(?:-|\/|\.|:)?(\d{1,2})?$/g, ary = [];
        this.replace(reg, function () {
            ary = ([].slice.call(arguments)).slice(1, 7);
        });
        var format = arguments[0] || "{0}年{1}月{2}日{3}:{4}:{5}";
        return format.replace(/{(\d+)}/g, function () {
            var val = ary[arguments[1]];
            return val.length === 1 ? "0" + val : val;
        });
    };
    var str = "2016-5-23 18:24:6";
    console.log(str.myFormatTime("{0}年{1}月{2}日"));//2016年05月23日
    console.log(str.myFormatTime("{1}-{2}"));//05-23
    console.log(str.myFormatTime("{0}年{1}月{2}日 {3}:{4}:{5}"));//2016年05月23日 18:24:06
```

5. URL 关键字提取，queryParameters

```
    var str = "http://kbs.sports.qq.com/kbsweb/game.htm?mid=100000:1468573&name=kbs#nba";//->这个就是B页面地址栏中的地址,我们需要获取的是{mid:"100000:1468573",name:"kbs"}
 //->正则处理
    var obj = {};
    str.replace(/([^?=&#]+)=([^?=&#]+)/g, function () {
        obj[arguments[1]] = arguments[2];
    });
    console.log(obj);
    
//其他方案:字符串的截取和拼接
     var strIndex = str.indexOf("?"),
                endIndex = str.lastIndexOf("#"),
                resStr = "";
        if (strIndex > -1) {
            if (endIndex === -1) {
                resStr = str.substring(strIndex + 1);
            } else {
                resStr = str.substring(strIndex + 1, endIndex);
            }
        }
        var ary = resStr.split("&"),
                obj = {};
        for (var i = 0; i < ary.length; i++) {
            var cur = ary[i],
                    curAry = cur.split("=");
            obj[curAry[0]] = curAry[1];
        }
        console.log(obj);
   
```

>+ 项目中常用的正则

- 有效数字的
  `var reg=/^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;`

- 邮箱的
`  var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;`

- 电话的
 ` var reg = /^(1\d{2})(\d{4})(?:\d{4})$/;`

- 年龄在18-65之间的
  `var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/;`

- 中文姓名`
`  var reg = /^[\u4e00-\u9fa5]{2,4}$/;`

- 身份证
 ` var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(?:\d|X)$/;`
  //-> 130828(省市县) 1990(年) 12(月) 04(日) 06 1(奇数是男偶数是女) 7(数字或者X)
